package it.unibo.service.citizen

import io.vertx.scala.ext.web.handler.BodyHandler
import io.vertx.scala.ext.web.{Router, RoutingContext}
import it.unibo.core.authentication.middleware.UserMiddleware
import it.unibo.core.microservice.vertx.{RestApi, _}
import it.unibo.core.microservice.{FutureService, Response}
import it.unibo.core.utils.{HttpCode, ServiceError}
import it.unibo.core.utils.ServiceError.MissingParameter

/**
 * HTTP REST API decoration for Citizen Verticle.
 * an example of usage (a lÃ  Cake pattern) follows:
 *
 * new CitizenVerticle(...) with RestCitizenApi
 *
 * the endpoints are:
 *  - GET host/citizens/{id}/state
 *  o OK(200): { data : [#DATA_SCHEMA] }
 *  # STANDARD_ERRORS
 *
 *  - GET host/citizens/{id}/state?data_category=xyz
 *  o OK(200): { data : [#DATA_SCHEMA] }
 *  # STANDARD_ERRORS
 *
 *  - GET host/citizens/{id}/history?data_category=xyz&limit=xyz
 *      limit is optional, default value => 1
 *  o OK(200): { data : [#DATA_SCHEMA] }
 *  # STANDARD_ERRORS
 *
 *  - GET host/citizens/{id}/history/{data_id}
 *  o OK(200): { data : #DATA_SCHEMA }
 *  # STANDARD_ERRORS
 *
 *  - PATCH host/citizens/{id}/state
 *    body : {
 *      "data" : [
 *        {
 *          "value" : #correct value based con category
 *          "category" : #string value that represent the leaf category
 *          "timestamp" : #long value
 *          "feeder" : {
 *            "isResource" : "true / false"
 *            "name" : #string value if isResource is false
 *            "uri" : #string value if isResource is true
 *          }
 *        }
 *      ]
 *    }
 *  o OK(200) : [#sequence of id created]
 *
 *  # STANDARD_ERRORS
 *  x UNAUTHORIZED(401)
 *  x FORBIDDEN(403)
 *  x INTERNAL_ERROR(500)
 *  x BAD_CONTENT(400)
 *
 *  #DATA_SCHEMA
 *  {
 *   "id" : #unique id generated by the server
 *   "value" : #correct value based con category
 *   "category" : #string value that represent the leaf category
 *   "timestamp" : #long value
 *   "feeder" : {
 *      "isResource" : "true / false"
 *      "name" : #string value if isResource is false
 *      "uri" : #string value if isResource is true
 *    }
 *  }
 * each request must set Authorization header as follow:
 * Authorization -> Bearer #authToken
 */
trait RestCitizenApi extends RestApi with RestServiceResponse {
  self : CitizenVerticle =>
  import CitizenVerticle._

  override def createRouter: Router = {
    val router = Router.router(vertx)
    val userMiddleware = UserMiddleware()

    CorsSupport.enableTo(router)

    router.get(self.citizenStateEndpoint)
      .handler(userMiddleware)
      .handler(handleGetState)

    router.patch(citizenStateEndpoint)
      .handler(BodyHandler.create())
      .handler(userMiddleware)
      .handler(handlePatchState)

    router.get(s"$historyEndpoint")
      .handler(userMiddleware)
      .handler(handleGetHistoryDataFromCategory)

    router.get(s"$historyEndpoint/:data_id")
      .handler(userMiddleware)
      .handler(handleGetHistoryData)
    router

    router.errorHandler(404, handler => println(handler.normalisedPath()))
  }

  private def handleGetState(context: RoutingContext): Unit = {
    val token = context.getToken(UserMiddleware.JWT_TOKEN)
    val getOperation = context.queryParams().get(categoryParamName) match {
      case None => citizenDT.readState(token)
      case Some(category) => parser.decodeCategory(category)
        .map(citizenDT.readStateByCategory(token, _))
        .getOrElse(FutureService.fail(MissingParameter(s"Invalid query value")))
    }

    sendServiceResponseWhenComplete(context, getOperation) {
      case Response(data) => (HttpCode.Ok, stateToJson(data).encode())
    }
  }

  private def handlePatchState(context: RoutingContext): Unit = {
    val token = context.getToken(UserMiddleware.JWT_TOKEN)
    val pending = context.getBodyAsJson()
      .map(jsonToState)
      .collect { case Some(data) => data }
      .map(newState => citizenDT.updateState(token, newState))
      .getOrElse(FutureService.fail(MissingParameter(s"Invalid json body")))

    sendServiceResponseWhenComplete(context, pending) {
      case Response(newData) => (HttpCode.Ok, seqToJsonArray(newData).encode())
    }
  }

  private def handleGetHistoryData(context: RoutingContext): Unit = {
    val token = context.getToken(UserMiddleware.JWT_TOKEN)
    val dataIdentifier = context.pathParam("data_id").get

    sendServiceResponseWhenComplete(context, citizenDT.readHistoryData(token, dataIdentifier)) {
      case Response(data) => (HttpCode.Ok, parser.encode(data).get.encode())
    }
  }

  private def handleGetHistoryDataFromCategory(context: RoutingContext): Unit = {
    val token = context.getToken(UserMiddleware.JWT_TOKEN)
    val dataCategory = context.queryParams().get(categoryParamName)
    val limit = context.queryParams().get("limit").getOrElse("1").toInt
    val pending = dataCategory
      .flatMap(parser.decodeCategory)
      .map(citizenDT.readHistory(token, _, limit))
      .getOrElse(FutureService.fail(MissingParameter(s"Missing or invalid data_category query parameter")))

    sendServiceResponseWhenComplete(context, pending) {
      case Response(value) => (HttpCode.Ok, dataArrayToJson(value).encode())
    }
  }
}
